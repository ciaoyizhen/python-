# 第十三章 购物篮分析

俗话说：“商场如战场。”那是指商人之间的斗争，而这种争斗要通过商品这一道具完成。商品如同它们的主人一样，有不同的个性及命运，而货架就是商品展开“厮杀”的“战场”。有的商品一帆风顺，成功进入客户手中的购物篮，帮助自己的主人完成使命，而有的商品在门店中郁郁寡欢，始终与客户手中的购物篮无缘，最终落得一个被赶下货架，扫地出门的悲惨结局。

不同的商品决定了不同商店的命运，这点很好理解，可是不能让大家理解的是开在相同位置的商店，卖的是同样的商品，甚至销售价格也差不多，为什么别人能够活的好好的，自己的商店却每况愈下，最终落得个凄凉倒闭的结局。商店倒闭的元凶很多，不了解客户手中的购物篮，从而失去客户的信赖是致命原因之一。



## 购物篮分析概述

### 什么是购物篮分析

顾名思义，购物篮指的是就是超级市场中供应顾客购物时使用的装商品的篮子，当顾客付款时，这些购物篮内的商品被营业人员通过收款机一一登记结算并记录。所谓的购物篮分析就是通过这些购物篮所显示的信息来研究顾客的购买行为。购物篮分析的主要目的在于找出什么样的东西应该放在一起，其目标是由顾客的购买行为来了解什么样的顾客以及这些顾客为什么买这些产品，找出相关的关联（Association）规则，企业借由这些规则的挖掘获得利益并建立竞争优势。举例来说，零售店可通过此分析改变货架上的商品排列或是设计吸引客户的商业套餐，等等。通过购物篮分析挖掘出来的信息可以指导交叉销售、追加销售、商品促销、顾客忠诚度管理、库存管理和折扣计划。

购物篮分析技术可以应用在下列问题上：

+ 针对信用卡购物，能够预测未来顾客可能购买什么。
+ 对于电信与金融服务业，通过购物篮分析能够设计不同的服务组合以扩大利润。
+ 保险业能通过购物篮分析侦测出可能不寻常的投保组合并进行预防。
+ 对病人而言，在疗程的组合上，购物篮分析能作为这些疗程组合是否会导致并发症的判断依据。

### 购物篮分析在超市中的应用

购物篮分析在大型超市的运营体系中占据了非常重要的地位。购物篮分析的结果不仅为门店的商品陈列、促销提供了有力的证据，更重要的是，通过它超市可以更充分了解客户的真实需求，并帮助供应商开发新产品。利用购物篮分析可以完成如下应用。

+ 商品配置分析：哪些商品可以一起购买，关联商品如何陈列、促销。
+ 客户需求分析：分析顾客的购买习惯，包括顾客购买商品的时间、地点等。
+ 销售趋势分析：利用数据仓库对品种和库存的趋势进行分析，选定需要补充的商品，研究顾客购买趋势，分析季节性购买模式，确定降价商品。
+ 帮助供应商改进老产品及开发新品：通过购物篮分析，根据客户的需求，开发新的产品或改进老产品及产品包装。



具体而言，超市根据商品在购物篮中出现的数量，可以分析商品包装和规格的机会点，为商品优化提供支持；而通过跟踪购物篮的变化，超市可以细分顾客消费行为及分析其对销售的影响；分析商品的销售趋势可以帮助制定有针对性的产品销售计划，提升顾客忠诚度。

例如，超市通过商品一级品类的购物篮分析，发现用户经常购买水果和乳品，这两个品种十分契合下午茶场景，进而考虑超市周围是办公区，那么借此就可以理解超市的用户群体中，办公室白领和比较喜欢下午茶的人群比例有多少；同时通过分析发现果蔬和乳品是另一大受欢迎的组合，这两个品种十分契合居家生活场景，对这一数据的分析可以了解在超市的顾客群体中，做饭居家的用户比例有多少。

有了这些数据佐证，超市一方面可以告诉运营部门在这几类品种上不断扩品和扩类，另一方面可以指导运营，在合适的时间（下午茶时间和下班买菜时间）进行合适的品类秒杀和促销。另外可以确定，如果要进行促销，那么促销品中加入哪款商品能促进该促销品的销售；如果要制定下午茶活动，或者是菜市场活动，选哪些品类比较合适。

而通过对顾客在购买某一目标产品时出现在同一购物篮里的关联最紧密的商品以及相关购买金额、数量、出现频率的分析，可以为运营部门在交叉陈列、销售、商品促销或开发复合包装产品时提供依据。知名的大型连锁超市沃尔玛利用购物篮分析获得丰厚收益的故事很多，这里介绍几个公开的案例。

+ 案例一：沃尔玛的采购人员在对一种礼品包装的婴儿护肤品进行购物篮分析时发现，该礼品的购买者基本都是一些商务卡客户，进一步了解才知道，商品都是作为礼品买来送人的，而不是原先预想的“母亲”客户买给自己的孩子。因此，该商品的购买目的才得以明确，这样的购买目的信息为商品的进一步改进提供了极大的帮助。
+ 案例二：通过对购物篮分析，沃尔玛发现，很多客户在购买沐浴用品时都会同时购买沐浴露这一类商品。这条信息提示，可以针对这种需求，将毛巾、沐浴球、洗澡用品与沐浴露等沐浴主题进行捆绑销售或进行相关沐浴用品主题陈列。
+ 案例三：美国著名饮料制造商Welch‘s有一种专门为情人节定制的果汁饮料，但是如何展示、陈列这种情人节专用饮料始终是个难题。通过购物篮分析发现，这种商品与情人节专用的糖果（如巧克力）、贺卡具有商品关联关系。因此，这种饮料在情人节前可与情人节专用季节性通道的糖果、贺卡放在一起，并成为情人节商品整体规划的一部分。



## 购物篮分析实现

### 原理的介绍

#### 项集

购物篮也称为事务数据集，它包含属于同一个项集的项集合。在一篮子商品的一件消费品即为一项（Item），若干个项的集合为项集（Items），如{婴儿奶粉，尿片}构成一个二元项集。

#### 关联规则

X为先决条件，Y为相应的关联结果，用于表示数据内隐含的关联性，如关联规则：尿片$\rightarrow$婴儿奶粉[支持度=3%, 置信度=80%]。



#### 支持度

支持度（support）是指在所有项集中，{X，Y}出现的可能性，即项集中同时含有X和Y的概率。假设全部交易中同时购买了婴儿奈何和尿片的概率是3/100=0.03，那么{尿片$\rightarrow$婴儿奶粉}的支持度为3%。支持度指标作为建立强关联规则的第一个门槛，衡量了所考察关联规则在“量”上的多少。



#### 置信度

置信度(Confidence)表示在先决条件X发生的条件下，关联结果Y发生的概率：
$$
Confidence(X\rightarrow Y)=Support(X, Y)/Support(X)
$$
如果在1000条交易记录中，100个购买尿片的顾客中有80个又购买了婴儿奶粉，即{尿片$\rightarrow$婴儿奶粉}的置信度为(80/1000)/(100/1000)=0.8。这是生成强关联规则的第二个门槛，衡量了所考察的关联规则在“质”上的可靠性。

#### 提升度

提升度（Lift）表示“使用X的用户中同时使用Y的比例”与“使用Y的用户比例”的比值：
$$
Lift(X\rightarrow Y)=(Support(X, Y)/Support(X))/(Support(Y))=Confidence(X\rightarrow Y)/Support(Y)
$$
交易记录中，有100个顾客买了尿片，有200个顾客买了婴儿奶粉，有80个顾客同时购买了尿片和婴儿奶粉，那么{尿片$\rightarrow$奶粉}的提升度为((80/1000)/(100/1000))/(200/1000)=0.8/0.2=4。

该指标与置信度同样用于衡量规则的可靠性，可以看作是置信度的一种互补指标。



#### 出错率

出错率(Conviction)的意义在于度量规则预测错误的概率，表示X出现而Y不出现的概率：
$$
Conviction(X\rightarrow Y)=(1-Support(Y))/(1-Confidence(X\rightarrow Y))
$$
那么{尿片$\rightarrow$婴儿奶粉}的出错率为(1-200/1000)/(1-0.8)=4





> 以上的各个指标中，
>
> 支持度是一种重要的度量，因为支持度很低的规则可能只是偶然出现，低支持度的规则多半也是无意义的。因此，支持度通常用来删去那些无意义的规则。
>
> 置信度度量的是通过规则进行推理的可靠性，对于给定规则的$X\rightarrow Y$，置信度越高，则Y在包含X的事物中出现的可能性就越大，即$Y$在给定$X$的条件概率越大。
>
> 提升度反映了关联规则中$A与B$的相关性。如果提升度等于1，说明A和B没有任何关系，如果小于1说明A和B是互斥的，只有大于1，才认为A和B是有关的。在实际应用中，一般认为提升度大于3才算作是被认可的关联。
>
> 一个大的提升度值是一个重要的指标，它表面一个规则是很重要的，并反映了商品之间的真实关系。选择哪个指标作为衡量指标，取决于数据分析的目标。如果数据分析是为了提高销量，那么选择考虑将支持度与置信度结合使用；如果数据分析目标是用于推荐，则考虑提升度会更有价值。



规则生成过程

:one:找频繁项集：在Apriori算法中，一个频繁项集的所有子集必须也是频繁的，即如果{樱花奶粉，尿片}是频繁集，那么{樱花奶粉}和{尿片}也是频繁集，也就是说想要进入后续的规则整理，该商品被采购概率必须大于或等于一个阈值（即Apriori函数中的support参数），n个项就可以产生$2^n-1$个项集，指定最小支持度就可以过滤掉非频繁项集，这样既能减轻计算负荷，又能提高预测质量。

:two:：找出频繁项集的规则：n个项总共可以产生$3^n-2^{n+1}+1$条规则（这个不知道怎么算的），指定最小置信度过滤掉弱规则。经过上一步的过滤，剩余的项集已能满足最低支持度。计算各项之间的置信度作为候选规则，将这些候选规则与最小置信度阈值相比较，不能满足最小置信度的规则将被消除。

简单理解：也就是先找单个项数目是够多的，然后两个进行组合，然后数量也要多，然后这就是规则。



## 购物篮实例分析

### Mlxtend库中Apriori算法使用介绍

购物篮分析最关键的就是构建频繁项集，之后根据它来构建规则。我们这里使用开源的Mlxtend库。

```python
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules
import pandas as pd
```

上述代码分别提供了交易记录编码转换、Apriori算法、关联规则的实现函数。

```python
# 随机数据

dataset = [['Milk', 'Onion', 'Nutmeg', 'Kidney Beans', 'Eggs', 'Yogurt'],
           ['Dill', 'Onion', 'Nutmeg', 'Kidney Beans', 'Eggs', 'Yogurt'],
           ['Milk', 'Apple', 'Kidney Beans', 'Eggs'],
           ['Milk', 'Unicorn', 'Corn', 'Kdiney Beans', 'Yogurt'],
           ['Corn', 'Onine', 'Onine', 'Kidney Beans', 'Ice cream', 'Eggs']]

# 数据转换
te_ary = te.fit(dataset).transform(dataset)
df = pd.DataFrame(te_ary, columns=te.columns_)

# 获取频繁集
apriori(df, min_support=0.6)  # 这个不会返回具体项的名称,若要返回具体项的名称,则需要指定use_columns=True
apriori(df, 0.6, True)
```

获取频繁集后，分析人员会根据支持度来选择与过滤。

```python
# 构造一个频繁集项数特征
frequent_itemsets = apriori(df, 0.6, True)
frequent_itemsets['length'] = frequent_itemsets['itemsets'].map(lambda x: len(x))
frequent_itemsets

# 过滤
frequent_itemsets[(frequent_itemsets['length']>=2) & (frequent_itemsets['support']>=0.8)]
```

### 在线销售数据购物篮分析

```python
import pandas as pd
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules

import matplotlib.pyplot as plt
import matplotlib as mpl
import seaborn as sns
import datetime

import warnings

warnings.filterwarnings('ignore')
sns.set_style('whitegrid')
plt.rcParams['font.sans-serif'] = 'SimHei'
plt.rcParams['axes.unicode_minus'] = False
colors = sns.color_palette()
%matplotlib inline
```

```python
file = r'../data/OnlineRetail.csv'
online = pd.read_csv(file, encoding='Unicode_escape', parse_dates=['InvoiceDate'])
online.sample(3)
```

数据集中一共有541909条交易记录，其中Description列提供了用户的购物描述，该列则是我们要分析的项。

通常我们在进行购物篮分析前会对交易中经常出现的购物项进行一个简单的探索性分析。

```python
df = online['Description'].value_counts()
data = df.head(20)
plt.figure(figsize=(8, 4), dpi=120)
plt.bar(data.index, data, color=colors[1])
plt.title('最20的频繁购买项')
plt.ylabel('计数')
plt.xlabel('购物项')
plt.xticks(rotation=90)
plt.show()
```

缺失值处理

```python
online.dropna(axis=0, subset=['Description'], inplace=True)
online.sample(5)

# 去除退款,其实这里这样处理是有问题的
online = online[~online['InvoiceNo'].str.contains('C')]
online.sample(5)
```



```python
basket = online.groupby(by=['InvoiceNo', 'Description']) ['Quantity'].sum().unstack().reset_index().fillna(0).set_index('InvoiceNo')
# 上面两行是一行!!!
# 具体解释一下,先是通过groupby,做成二级索引,value为Quantity.sum的Series,通过unstack把二级索引的Decription分到了列名,然后value值为count,但是这个unstack是把整个二级索引的值都换在了列名,对于这一级索引没有的话,会被赋值为NaN
basket
```

这里是为了处理内容中的邮费

```python
def encode_units(x):
    if x<= 0:
        return 0
    if x>= 1:
        return 1

basket_sets = basket.applymap(encode_units)
basket_sets.drop('POSTAGE', inplace=True, axis=1)  # 有一项是邮费,不应该放入我们的关联规则
```

```python
# 这里好像内存不够做不了。  colab实现了

frequent_itemsets = apriori(basket_sets, min_support=0.02, use_colnames=True)
frequent_itemsets['length'] = frequent_itemsets['itemsets'].apply(lambda x: len(x))
```

```python
rulers = association_rules(frequent_itemsets, metric='lift', min_threshold=3)  # 这里会输出所有指标，但是阈值是根据你值来的
rulers
```



